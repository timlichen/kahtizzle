<!DOCTYPE html>
<html lang="en" ng-app='myApp'>
<head>
  <meta charset="UTF-8">
  <title>Index Page</title>
  <script type="text/javascript" src="js/lib/angular.js"></script>
  <script type="text/javascript" src="js/lib/angular-route.js"></script>

  <script type="text/javascript">
    var myAppObject  = angular.module('myApp', ['ngRoute'])

    //Angular Partial Routes
    myAppObject.config(function($routeProvider){
      $routeProvider
      .when('/', {
        redirectTo: '/login'
      })
      .when('/login', {
        templateUrl: 'partials/login.partial.html',
        controller: 'SessionsController',
        controllerAs: 'sessionsCtrl'
      })
      .when('/registration', {
        templateUrl: 'partials/registration.partial.html',
        controller: 'UsersController',
        controllerAs: 'usersCtrl'
      })
      .when('/dashboard', {
        templateUrl: 'partials/dashboard.partial.html',
        controller: 'DashboardsController',
        controllerAs: 'dashboardCtrl'
      })
      .otherwise({
        redirectTo: '/'
      })
    })

    myAppObject.controller('DashboardsController', function(SessionFactory){
      var _this = this;
      var available_tiles = {
        sheep:  4,
        wheat:  4,
        wood:   4,
        brick:  3,
        ore:    3,
        desert: 1,
      };
      var total_tiles = 19;

      // List of possible rolls and their probability and piece count
      var circle_options = {
        '2':  {prob: 1, count: 1},
        '3':  {prob: 2, count: 2},
        '4':  {prob: 3, count: 2},
        '5':  {prob: 4, count: 2},
        '6':  {prob: 5, count: 2},
        '8':  {prob: 5, count: 2},
        '9':  {prob: 4, count: 2},
        '10': {prob: 3, count: 2},
        '11': {prob: 2, count: 2},
        '12': {prob: 1, count: 1}
      };

      // Make array of all available circle roll options (ex: [2,3,3,4,4,...,12])
      var rolls = [];
      for (var opt in circle_options) {
        for (var i = 0; i < circle_options[opt].count; i++) {
          rolls.push(opt);
        }
      }

      // Hex point coordinates of 'origin' hex that starts a row
      // A row run lineally NE to SW
      var row_coords = [
        {cx: 680, cy: 128},
        {cx: 635, cy: 50},
        {cx: 545, cy: 50},
        {cx: 500, cy: 128},
        {cx: 545, cy: 206},
        {cx: 635, cy: 206}
      ];

      var rowbgx = 497;
      var rowbgy = 50;
      var vertices_coord = [];

      // List of all the intersections/vertices
      _this.allvertices = [];

      // List of all hexes on board
      _this.allhexes = [];

      // List of all edges on board
      _this.alledges = [];

      function makeAllHexes () {
        // Available tile ids
        var avail = [];
        // Make array of all available ids (ex: [1,2,3,...,19])
        for (var t = 1; t <= total_tiles; t++) {
          avail.push(t);
        }
        // Go through all tiles by type
        for (var tile_type in available_tiles) {
          for (var i = 0; i < available_tiles[tile_type]; i++) {
            // Get random available id
            var pos = Math.floor((Math.random() * (avail.length - 1)));
            var temp = avail[pos];
            avail[pos] = avail[avail.length - 1];
            avail[avail.length - 1] = temp;
            avail.pop();
            // Assign tile type and id to new hex
            makeHex(tile_type, temp);
          }
        }
      }

      function makeHex (tile_type, id) {
        hex = {
          hex_id:    id,
          tile_type: tile_type,
          circle:    tile_type !== 'desert' && makeCircle(),
          // coord, bgx, bgy, & row have these as default values, but they get changed anyway
          coord: [
            {cx: 680, cy: 78},  // E
            {cx: 635, cy: 0},   // NE
            {cx: 545, cy: 0},   // NW
            {cx: 500, cy: 78},  // W
            {cx: 545, cy: 156}, // SW
            {cx: 635, cy: 156}  // SE
          ],
          bgx: 497,
          bgy: 0,
          coordinates: '680,78 635,0 545,0 500,78 545,156 635,156',
          row: 0
        };
        _this.allhexes.push(hex);
      }

      // Creates central circle with roll number, chance, dots, etc.
      function makeCircle () {
        var pos = Math.floor((Math.random() * (rolls.length - 1)));
        var roll = rolls[pos];
        rolls[pos] = rolls[rolls.length - 1];
        rolls[rolls.length - 1] = roll;
        rolls.pop();

        // Make the dots below the roll number
        var dotstring = '';
        for (var i = 0; i < circle_options[roll].prob; i++) {
          dotstring += '.';
        }

        return {
          roll: roll,
          color: (roll == 6 || roll == 8) ? 'red' : 'black',
          chance: Math.round((circle_options[roll].prob / 36) * 100),
          dots: dotstring
        };
      }

      

      //////////////////////////////////////////////////////
      // Create all the TILES needed for a starting board //
      //////////////////////////////////////////////////////
      makeAllHexes();
      // Organize the hexes by id, not tile type
      _this.allhexes = _this.allhexes.sort(function (a, b) {
        if (a.hex_id < b.hex_id) {
          return -1;
        } else if (a.hex_id > b.hex_id) {
          return 1;
        } else {
          return 0;
        }
      });

      _this.allhexes[0].row = 1;
      // Gives coordinates for tile positioning
      var nth_in_row = 0;
      var row = 1;

      // Go through all tiles, remake their vertices coordinates
      for (var t = 0; t < _this.allhexes.length; t++) {
        // For tiles that start new rows
        if (t == 3 || t == 7 || t == 12 || t == 16) {
          row++;
          nth_in_row = 0;
          var dx = 0;
          var dy = 0;
          if (t == 3 || t == 7) {
            dx = 135;
            dy = 78;
          } else if (t == 12 || t == 16) {
            dx = 0;
            dy = 156;
          }
          // Reset row origin
          for (var d = 0; d < 6; d++) {
            row_coords[d].cx += dx;
            row_coords[d].cy += dy;
            _this.allhexes[t].coord[d].cx = row_coords[d].cx;
            _this.allhexes[t].coord[d].cy = row_coords[d].cy;
            makeAllVertices(row_coords[d].cx, row_coords[d].cy, _this.allhexes[t].hex_id);
          }
          // Reset background image origin
          rowbgx += dx;
          rowbgy += dy;
          _this.allhexes[t].bgx = rowbgx;
          _this.allhexes[t].bgy = rowbgy;
        } else {
          // 'Regular' tiles not at the start of a row
          // Update with proper coordinates
          for (var d = 0; d < 6; d++) {
            _this.allhexes[t].coord[d].cx = row_coords[d].cx - (nth_in_row * 135);
            _this.allhexes[t].coord[d].cy = row_coords[d].cy + (nth_in_row * 78);
            makeAllVertices(_this.allhexes[t].coord[d].cx, _this.allhexes[t].coord[d].cy, _this.allhexes[t].hex_id);
          }
          _this.allhexes[t].bgx = rowbgx - (nth_in_row * 135);
          _this.allhexes[t].bgy = rowbgy + (nth_in_row * 78);
        }
        nth_in_row++;
        _this.allhexes[t].row = row;
      }
      // END tile positioning

      /////////////////////////////////////////////////////////
      // Create all the VERTICES needed for a starting board //
      /////////////////////////////////////////////////////////
      // Add singular vertex (coordinates and hex_id) to _this.allvertices
      function makeAllVertices (x, y, hex_id) {
        var vertex_id = x + '_' + y;
        var found = false;
        // Check list of taken vertex coordinates
        for (vertex in _this.allvertices) {
          // Find the vertex object by vertex_id, add this hex to the list of touching tiles
          if (_this.allvertices[vertex].vertex_id == vertex_id) {
            _this.allvertices[vertex].tiles.push(hex_id);
            found = true;
            break;
          }
        }
        if (!found) {
          // Push single VERTEX
          _this.allvertices.push({
            vertex_id: vertex_id,
            x: x, 
            y: y, 
            tiles: [hex_id],
            color: 'gray'
           });
        }
      }

      //////////////////////////////////////////////////////
      // Create all the EDGES needed for a starting board //
      //////////////////////////////////////////////////////
      makeAllEdges();
      function makeAllEdges () {
        for (hex in _this.allhexes) {
          var _h = _this.allhexes[hex];
          for (var h = 0; h < 5; h++) {
            makeEdge(_h.coord[h], _h.coord[h + 1]);
          }
          makeEdge(_h.coord[5], _h.coord[0]);
        }
        function makeEdge (a, b) {
          var end_a = a.cx + ',' + a.cy;
          var end_b = b.cx + ',' + b.cy;
          // Need ordered coords, otherwise duplicate edges may register under difference ids
          var edge_id = a.cx < b.cx ? end_a + '_' + end_b : end_b + '_' + end_a;
          for (var i = 0; i < _this.alledges.length; i++) {
            if (_this.alledges[i].edge_id == edge_id) {
              return -1;
            }
          }
          // Push single EDGE
          _this.alledges.push({
            edge_id: end_a + '_' + end_b,
            end_a: {string: end_a, x: a.cx, y: a.cy, obj: false},
            end_b: {string: end_b, x: b.cx, y: b.cy, obj: false},
            owner: false,
            color: 'RGB(252,210,9)',
            hovered: false,
            clicked: false
          });
        }
      }

      console.log('_this.allhexes', _this.allhexes);
      console.log('_this.allvertices', _this.allvertices);
      console.log('_this.alledges', _this.alledges);

      _this.clickVertex = function (vertex_id) {
        console.log('CLICKED!', vertex_id);
        for (vertex in _this.allvertices) {
          if (_this.allvertices[vertex].vertex_id == vertex_id) {
            _this.allvertices[vertex].color = 'white';
          }
        }
      }
      _this.alarm = function (ob) {
        console.log('YUGIOH', ob);
      }



      console.log('DashboardsController Loaded');

      // Commented out temporarily so you don't have to log in every time you refresh while testing
      // SessionFactory.authenticate();
    });

    myAppObject.controller('UsersController', function(UserFactory){
      var _this = this;
      console.log("UsersController Loaded...")
      this.create = function(newUser){
        _this.errors = {}; //CLEAN errors on each new call so old errors do no persist
        if(newUser){
          console.log('UsersController / creating', newUser);
          UserFactory.create(newUser, function(errors){ //MARK
            // console.log('Called back from UsersFactory Create');
            console.log('###', errors);
            //This ties it to the parent "this" instance allowing it to be displayed on the registration partial.
            _this.errors = errors;
          })
        }
      }
    });

    myAppObject.factory('UserFactory', function($http, $location){
      var factory = {
        create: function(newUser, callback){
          console.log('user', newUser);
          $http.post('/users', newUser).success(function(response){
            console.log("server responded post('/users')", response)
            if(response.errors){
              //this will return an object of objects, passing back to the controller callback function on line marked line
              callback(response.errors);

            } else {
              $location.path('/login');
              console.log('no errors')};
          })
        }
      }
      return factory;
    })

    myAppObject.controller('SessionsController', function(SessionFactory){
      console.log("SessionsController Loaded...")
      var _this = this;
      this.create = function(user){
      // CLEANING error
      // -- this causes an empty object when nothing is submitted --
      // _this.error = {};
        if(user){
          console.log('SessionsController / create', user);
          SessionFactory.create(user, function(user){
            if(user.error){
              _this.error = user.error
            }
            console.log('create back from factory');
          })
        }
      }
    });

    myAppObject.factory('SessionFactory', function($http, $location){
      var logged_in_user;
      var factory = {

      create: function(user, callback){
        console.log('user', user);
        $http.post('/sessions', user).success(function(response){
          if(response){
            logged_in_user = response;
            $location.path('/dashboard')
            callback(response);
          }else {
            callback({error: "Invalid Credentials"})
          }
        })
      },

      authenticate: function(){
          $http.get('/authenticate').success(function(response){
            if(!response){
              console.log('server says no');
              alert('You are logged out');
              $location.path('/login');
            }
          })
        }
      }

      return factory;
    })

  </script>
</head>
<body>
  <h1>Index</h1>
  <div ng-view></div>
</body>
</html>